use crate::{Error, HashAlgorithm, Kind};

/// The ElcAlgorithm.
///
/// The ElcAlgorithm is a hash algorithm that uses the first and last characters of a word to generate
/// a hash value. The hash value is then used to generate a row and column index.
/// The number of values that can be represented by the hash value is determined by the number of
/// characters in the alphabet and the number of characters to use from the beginning and end of a
/// word. The number of values that can be represented by the hash value is equal to the number of
/// characters in the alphabet raised to the power of the number of characters to use from the
/// beginning and end of a word.
#[derive(Debug)]
pub struct ElcAlgorithm {
    /// The number of characters to use from the beginning and end of a word.
    elc: usize,

    /// The number of values that can be represented by a letter from the word.
    num_vals: usize,
}

impl ElcAlgorithm {
    /// Creates a new ElcAlgorithm.
    ///
    /// # Parameters
    /// * `elc` - The number of characters to use from the beginning and end of a word.
    /// * `num_vals` - The number of values that can be represented by a letter from the word.
    #[must_use]
    pub fn new(elc: usize, num_vals: usize) -> Self {
        Self { elc, num_vals }
    }

    /// Converts a character to an index.
    ///
    /// # Parameters
    /// * `c` - A character.
    ///
    /// # Returns
    /// An index.
    fn char_to_index(c: char) -> usize {
        assert!(c.is_ascii_uppercase());
        (c as usize) - ('A' as usize)
    }

    /// Step to the next index level for each elc position.
    ///
    /// # Parameters
    /// * `acc` - The accumulated value.
    /// * `x` - The current value.
    ///
    /// # Returns
    /// The next value.
    fn step(&self, acc: usize, x: usize) -> usize {
        (acc * self.num_vals) + x
    }
}

impl HashAlgorithm for ElcAlgorithm {
    /// Hash function h1 that is used internally to generate row indices.
    /// The hash value is generated by taking the first `elc` characters of the word.
    ///
    /// # Parameters
    /// * `word` - A word to be hashed.
    ///
    /// # Returns
    /// A hash value.
    ///
    /// # Errors
    /// Will return `Err` if `word` is not a valid word.
    fn h1(&self, word: &str) -> Result<usize, Error> {
        if word.len() < self.elc {
            return Err(Error::new(Kind::ElcAlgorithmError(format!(
                "Expected word length ({word_len}) to be greater than or equal to elc ({elc}).",
                word_len = word.len(),
                elc = self.elc
            ))));
        }

        // Check that the first `elc` characters are uppercase letters.
        if word.chars().take(self.elc).all(|c| c.is_ascii_uppercase()) {
            // Convert the first `elc` characters to an index.
            let x: usize = word
                .chars()
                .take(self.elc)
                .map(ElcAlgorithm::char_to_index)
                .fold(0, |acc, x| self.step(acc, x));
            Ok(x)
        } else {
            Err(Error::new(Kind::ElcAlgorithmError(format!(
                "Unexpected character(s) encountered ({word}) in indices (0..{elc}).",
                word = word,
                elc = self.elc
            ))))
        }
    }

    /// A string representation of the h1 function.
    /// The string representation can be used to implement the h1 hash function in another language.
    ///
    /// # Returns
    /// A string representation of the h1 function.
    fn h1_as_text(&self) -> String {
        format!(
            "\n        val = 0
        for x in word_letters[0..{elc}]:
            val += (val * {num_vals}) + ord(x) - ord('A')",
            elc = self.elc - 1,
            num_vals = self.num_vals
        )
    }

    /// Hash function h2 that is used internally to generate column indices.
    /// The hash value is generated by taking the last `elc` characters of the word.
    ///
    /// # Parameters
    /// * `word` - A word to be hashed.
    ///
    /// # Returns
    /// A hash value.
    fn h2(&self, word: &str) -> Result<usize, Error> {
        if word.len() < self.elc {
            return Err(Error::new(Kind::ElcAlgorithmError(format!(
                "Expected word length ({word_len}) to be greater than or equal to elc ({elc}).",
                word_len = word.len(),
                elc = self.elc
            ))));
        }

        // Check that the last `elc` characters are uppercase letters.
        if word.chars().take(self.elc).all(|c| c.is_ascii_uppercase()) {
            // Convert the last `elc` characters to an index.
            let x: usize = word
                .chars()
                .rev()
                .take(self.elc)
                .map(ElcAlgorithm::char_to_index)
                .fold(0, |acc, x| self.step(acc, x));
            Ok(x)
        } else {
            Err(Error::new(Kind::ElcAlgorithmError(format!(
                "Unexpected character(s) encountered ({word}) in indices (0..{elc}).",
                word = word,
                elc = self.elc
            ))))
        }
    }

    /// A string representation of the h2 function.
    /// The string representation can be used to implement the h2 hash function in another language.
    ///
    /// # Returns
    /// A string representation of the h2 function.
    fn h2_as_text(&self) -> String {
        format!(
            "\n        val = 0
        for x in word_letters[-1..-{elc}]:
            val += (val * {num_vals}) + ord(x) - ord('A')",
            elc = self.elc,
            num_vals = self.num_vals
        )
    }
}

impl Default for ElcAlgorithm {
    /// Creates a new instance of the ElcAlgorithm with the default values.
    fn default() -> Self {
        Self {
            elc: 1,
            num_vals: 26,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn elc_algorithm_unit_test() {
        assert_eq!(ElcAlgorithm::char_to_index('A'), 0);
        assert_eq!(ElcAlgorithm::char_to_index('B'), 1);
        assert_eq!(ElcAlgorithm::char_to_index('Z'), 25);

        // ----
        let hash_algorithm: ElcAlgorithm = ElcAlgorithm::default();

        assert_eq!(hash_algorithm.h1("A").unwrap(), 0);
        assert_eq!(hash_algorithm.h1("B").unwrap(), 1);
        assert_eq!(hash_algorithm.h1("Z").unwrap(), 25);
        assert_eq!(hash_algorithm.h1("AA").unwrap(), 0);

        assert_eq!(hash_algorithm.h2("A").unwrap(), 0);
        assert_eq!(hash_algorithm.h2("B").unwrap(), 1);
        assert_eq!(hash_algorithm.h2("Z").unwrap(), 25);
        assert_eq!(hash_algorithm.h2("AA").unwrap(), 0);
        assert_eq!(hash_algorithm.h2("AB").unwrap(), 1);
        assert_eq!(hash_algorithm.h2("AZ").unwrap(), 25);
        assert_eq!(hash_algorithm.h2("BA").unwrap(), 0);

        assert_eq!(hash_algorithm.step(0, 0), 0);
        assert_eq!(hash_algorithm.step(0, 1), 1);
        assert_eq!(hash_algorithm.step(1, 0), 26);
        assert_eq!(hash_algorithm.step(1, 1), 27);

        // ----
        let hash_algorithm: ElcAlgorithm = ElcAlgorithm::new(2, 26);

        assert_eq!(hash_algorithm.h1("AA").unwrap(), 0);
        assert_eq!(hash_algorithm.h1("AB").unwrap(), 1);
        assert_eq!(hash_algorithm.h1("AZ").unwrap(), 25);
        assert_eq!(hash_algorithm.h1("BA").unwrap(), 26);
        assert_eq!(hash_algorithm.h1("BB").unwrap(), 27);

        assert_eq!(hash_algorithm.h2("AA").unwrap(), 0);
        assert_eq!(hash_algorithm.h2("AB").unwrap(), 26);
        assert_eq!(hash_algorithm.h2("AZ").unwrap(), 650);
        assert_eq!(hash_algorithm.h2("BA").unwrap(), 1);
        assert_eq!(hash_algorithm.h2("BB").unwrap(), 27);
        assert_eq!(hash_algorithm.h2("BZ").unwrap(), 651);
        assert_eq!(hash_algorithm.h2("CA").unwrap(), 2);
        assert_eq!(hash_algorithm.h2("ZZ").unwrap(), 675);

        assert_eq!(hash_algorithm.step(0, 0), 0);
        assert_eq!(hash_algorithm.step(0, 1), 1);
        assert_eq!(hash_algorithm.step(1, 0), 26);
        assert_eq!(hash_algorithm.step(1, 1), 27);

        match hash_algorithm.h1("A").unwrap_err().kind() {
            Kind::ElcAlgorithmError(msg) => {
                assert_eq!(
                    msg,
                    "Expected word length (1) to be greater than or equal to elc (2)."
                );
            }
            _ => panic!("Unexpected error type."),
        };

        match hash_algorithm.h1("aA").unwrap_err().kind() {
            Kind::ElcAlgorithmError(msg) => {
                assert_eq!(
                    msg,
                    "Unexpected character(s) encountered (aA) in indices (0..2)."
                );
            }
            _ => panic!("Unexpected error type."),
        };

        match hash_algorithm.h2("A").unwrap_err().kind() {
            Kind::ElcAlgorithmError(msg) => {
                assert_eq!(
                    msg,
                    "Expected word length (1) to be greater than or equal to elc (2)."
                );
            }
            _ => panic!("Unexpected error type."),
        };

        match hash_algorithm.h2("aA").unwrap_err().kind() {
            Kind::ElcAlgorithmError(msg) => {
                assert_eq!(
                    msg,
                    "Unexpected character(s) encountered (aA) in indices (0..2)."
                );
            }
            _ => panic!("Unexpected error type."),
        };

        assert_ne!(hash_algorithm.h1_as_text().len(), 0);
        assert_ne!(hash_algorithm.h2_as_text().len(), 0);

        println!("{hash_algorithm:?}");
    }
}
